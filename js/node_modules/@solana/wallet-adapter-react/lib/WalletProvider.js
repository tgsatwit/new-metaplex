var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { WalletNotConnectedError, WalletNotReadyError } from '@solana/wallet-adapter-base';
import React, { useCallback, useEffect, useMemo, useState } from 'react';
import { WalletNotSelectedError } from './errors';
import { useLocalStorage } from './useLocalStorage';
import { WalletContext } from './useWallet';
export const WalletProvider = ({ children, wallets, autoConnect = false, onError = (error) => console.error(error), localStorageKey = 'walletName', }) => {
    const [name, setName] = useLocalStorage(localStorageKey, null);
    const [wallet, setWallet] = useState();
    const [adapter, setAdapter] = useState();
    const [ready, setReady] = useState(false);
    const [connecting, setConnecting] = useState(false);
    const [disconnecting, setDisconnecting] = useState(false);
    const [connected, setConnected] = useState(false);
    const [autoApprove, setAutoApprove] = useState(false);
    const [publicKey, setPublicKey] = useState(null);
    const walletsByName = useMemo(() => wallets.reduce((walletsByName, wallet) => {
        walletsByName[wallet.name] = wallet;
        return walletsByName;
    }, {}), [wallets]);
    const select = useCallback((selected) => __awaiter(void 0, void 0, void 0, function* () {
        if (name === selected)
            return;
        if (adapter)
            yield adapter.disconnect();
        setName(selected);
    }), [name, adapter, setName]);
    const reset = useCallback(() => {
        setReady(false);
        setConnecting(false);
        setDisconnecting(false);
        setConnected(false);
        setAutoApprove(false);
        setPublicKey(null);
    }, [setReady, setConnecting, setDisconnecting, setConnected, setAutoApprove, setPublicKey]);
    const onReady = useCallback(() => setReady(true), [setReady]);
    const onConnect = useCallback(() => {
        if (!adapter)
            return;
        setConnected(true);
        setAutoApprove(adapter.autoApprove);
        setPublicKey(adapter.publicKey);
    }, [adapter, setConnected, setAutoApprove, setPublicKey]);
    const onDisconnect = useCallback(() => reset(), [reset]);
    const connect = useCallback(() => __awaiter(void 0, void 0, void 0, function* () {
        if (connecting || disconnecting || connected)
            return;
        if (!wallet || !adapter) {
            const error = new WalletNotSelectedError();
            onError(error);
            throw error;
        }
        if (!ready) {
            window.open(wallet.url, '_blank');
            const error = new WalletNotReadyError();
            onError(error);
            throw error;
        }
        setConnecting(true);
        try {
            yield adapter.connect();
        }
        finally {
            setConnecting(false);
        }
    }), [connecting, disconnecting, connected, adapter, onError, ready, wallet, setConnecting]);
    const disconnect = useCallback(() => __awaiter(void 0, void 0, void 0, function* () {
        if (disconnecting)
            return;
        if (!adapter) {
            yield select(null);
            return;
        }
        setDisconnecting(true);
        try {
            yield adapter.disconnect();
        }
        finally {
            setDisconnecting(false);
            yield select(null);
        }
    }), [disconnecting, adapter, select, setDisconnecting]);
    const signTransaction = useCallback((transaction) => __awaiter(void 0, void 0, void 0, function* () {
        if (!adapter) {
            const error = new WalletNotSelectedError();
            onError(error);
            throw error;
        }
        if (!connected) {
            const error = new WalletNotConnectedError();
            onError(error);
            throw error;
        }
        return yield adapter.signTransaction(transaction);
    }), [adapter, onError, connected]);
    const signAllTransactions = useCallback((transactions) => __awaiter(void 0, void 0, void 0, function* () {
        if (!adapter) {
            const error = new WalletNotSelectedError();
            onError(error);
            throw error;
        }
        if (!connected) {
            const error = new WalletNotConnectedError();
            onError(error);
            throw error;
        }
        return yield adapter.signAllTransactions(transactions);
    }), [adapter, onError, connected]);
    // Reset state and set the wallet, adapter, and ready state when the name changes
    useEffect(() => {
        reset();
        const wallet = name ? walletsByName[name] : undefined;
        const adapter = wallet ? wallet.adapter() : undefined;
        setWallet(wallet);
        setAdapter(adapter);
        setReady(adapter ? adapter.ready : false);
    }, [reset, name, walletsByName, setWallet, setAdapter, setReady]);
    // Setup and teardown event listeners when the adapter changes
    useEffect(() => {
        if (adapter) {
            adapter.on('ready', onReady);
            adapter.on('connect', onConnect);
            adapter.on('disconnect', onDisconnect);
            adapter.on('error', onError);
            return () => {
                adapter.off('ready', onReady);
                adapter.off('connect', onConnect);
                adapter.off('disconnect', onDisconnect);
                adapter.off('error', onError);
            };
        }
    }, [adapter, onReady, onConnect, onDisconnect, onError]);
    // If autoConnect is enabled, try to connect when the adapter changes and is ready
    useEffect(() => {
        if (autoConnect && adapter && ready) {
            (function () {
                return __awaiter(this, void 0, void 0, function* () {
                    setConnecting(true);
                    try {
                        yield adapter.connect();
                    }
                    catch (error) {
                        // Don't throw error, but onError will still be called
                    }
                    finally {
                        setConnecting(false);
                    }
                });
            })();
        }
    }, [autoConnect, adapter, ready, setConnecting]);
    return (React.createElement(WalletContext.Provider, { value: {
            wallets,
            autoConnect,
            wallet,
            select,
            publicKey,
            ready,
            connecting,
            disconnecting,
            connected,
            autoApprove,
            connect,
            disconnect,
            signTransaction,
            signAllTransactions,
        } }, children));
};
//# sourceMappingURL=WalletProvider.js.map