{"ast":null,"code":"import _toConsumableArray from\"/Users/timgillam/Documents/GitHub/metaplex_new/new-metaplex/js/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _regeneratorRuntime from\"/Users/timgillam/Documents/GitHub/metaplex_new/new-metaplex/js/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/timgillam/Documents/GitHub/metaplex_new/new-metaplex/js/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{Transaction}from'@solana/web3.js';import{WalletNotConnectedError}from'@solana/wallet-adapter-base';export var getErrorForTransaction=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(connection,txid){var tx,errors;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return connection.confirmTransaction(txid,'max');case 2:_context.next=4;return connection.getParsedConfirmedTransaction(txid);case 4:tx=_context.sent;errors=[];if((tx===null||tx===void 0?void 0:tx.meta)&&tx.meta.logMessages){tx.meta.logMessages.forEach(function(log){var regex=/Error: (.*)/gm;var m;while((m=regex.exec(log))!==null){// This is necessary to avoid infinite loops with zero-width matches\nif(m.index===regex.lastIndex){regex.lastIndex++;}if(m.length>1){errors.push(m[1]);}}});}return _context.abrupt(\"return\",errors);case 8:case\"end\":return _context.stop();}}},_callee);}));return function getErrorForTransaction(_x,_x2){return _ref.apply(this,arguments);};}();export var SequenceType;(function(SequenceType){SequenceType[SequenceType[\"Sequential\"]=0]=\"Sequential\";SequenceType[SequenceType[\"Parallel\"]=1]=\"Parallel\";SequenceType[SequenceType[\"StopOnFailure\"]=2]=\"StopOnFailure\";})(SequenceType||(SequenceType={}));export function sendTransactionsWithManualRetry(_x3,_x4,_x5,_x6){return _sendTransactionsWithManualRetry.apply(this,arguments);}function _sendTransactionsWithManualRetry(){_sendTransactionsWithManualRetry=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5(connection,wallet,instructions,signers){var stopPoint,tries,lastInstructionsLength,toRemoveSigners,filteredSigners;return _regeneratorRuntime.wrap(function _callee5$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:stopPoint=0;tries=0;lastInstructionsLength=null;toRemoveSigners={};instructions=instructions.filter(function(instr,i){if(instr.length>0){return true;}else{toRemoveSigners[i]=true;return false;}});filteredSigners=signers.filter(function(_,i){return!toRemoveSigners[i];});case 6:if(!(stopPoint<instructions.length&&tries<3)){_context6.next=29;break;}instructions=instructions.slice(stopPoint,instructions.length);filteredSigners=filteredSigners.slice(stopPoint,filteredSigners.length);if(instructions.length===lastInstructionsLength)tries=tries+1;else tries=0;_context6.prev=10;if(!(instructions.length===1)){_context6.next=17;break;}_context6.next=14;return sendTransactionWithRetry(connection,wallet,instructions[0],filteredSigners[0],'single');case 14:stopPoint=1;_context6.next=20;break;case 17:_context6.next=19;return sendTransactions(connection,wallet,instructions,filteredSigners,SequenceType.StopOnFailure,'single');case 19:stopPoint=_context6.sent;case 20:_context6.next=25;break;case 22:_context6.prev=22;_context6.t0=_context6[\"catch\"](10);console.error(_context6.t0);case 25:console.log('Died on ',stopPoint,'retrying from instruction',instructions[stopPoint],'instructions length is',instructions.length);lastInstructionsLength=instructions.length;_context6.next=6;break;case 29:case\"end\":return _context6.stop();}}},_callee5,null,[[10,22]]);}));return _sendTransactionsWithManualRetry.apply(this,arguments);}export var sendTransactions=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(connection,wallet,instructionSet,signersSet){var sequenceType,commitment,successCallback,failCallback,block,unsignedTxns,_loop,i,_ret,signedTxns,pendingTxns,breakEarlyObject,_loop2,_i,_ret2,_args3=arguments;return _regeneratorRuntime.wrap(function _callee2$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:sequenceType=_args3.length>4&&_args3[4]!==undefined?_args3[4]:SequenceType.Parallel;commitment=_args3.length>5&&_args3[5]!==undefined?_args3[5]:'singleGossip';successCallback=_args3.length>6&&_args3[6]!==undefined?_args3[6]:function(txid,ind){};failCallback=_args3.length>7&&_args3[7]!==undefined?_args3[7]:function(txid,ind){return false;};block=_args3.length>8?_args3[8]:undefined;if(wallet.publicKey){_context3.next=7;break;}throw new WalletNotConnectedError();case 7:unsignedTxns=[];if(block){_context3.next=12;break;}_context3.next=11;return connection.getRecentBlockhash(commitment);case 11:block=_context3.sent;case 12:_loop=function _loop(i){var instructions=instructionSet[i];var signers=signersSet[i];if(instructions.length===0){return\"continue\";}var transaction=new Transaction();instructions.forEach(function(instruction){return transaction.add(instruction);});transaction.recentBlockhash=block.blockhash;transaction.setSigners.apply(transaction,[// fee payed by the wallet owner\nwallet.publicKey].concat(_toConsumableArray(signers.map(function(s){return s.publicKey;}))));if(signers.length>0){transaction.partialSign.apply(transaction,_toConsumableArray(signers));}unsignedTxns.push(transaction);};i=0;case 14:if(!(i<instructionSet.length)){_context3.next=21;break;}_ret=_loop(i);if(!(_ret===\"continue\")){_context3.next=18;break;}return _context3.abrupt(\"continue\",18);case 18:i++;_context3.next=14;break;case 21:_context3.next=23;return wallet.signAllTransactions(unsignedTxns);case 23:signedTxns=_context3.sent;pendingTxns=[];breakEarlyObject={breakEarly:false,i:0};console.log('Signed txns length',signedTxns.length,'vs handed in length',instructionSet.length);_loop2=/*#__PURE__*/_regeneratorRuntime.mark(function _loop2(_i){var signedTxnPromise;return _regeneratorRuntime.wrap(function _loop2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:signedTxnPromise=sendSignedTransaction({connection:connection,signedTransaction:signedTxns[_i]});signedTxnPromise.then(function(_ref3){var txid=_ref3.txid,slot=_ref3.slot;successCallback(txid,_i);}).catch(function(reason){// @ts-ignore\nfailCallback(signedTxns[_i],_i);if(sequenceType===SequenceType.StopOnFailure){breakEarlyObject.breakEarly=true;breakEarlyObject.i=_i;}});if(!(sequenceType!==SequenceType.Parallel)){_context2.next=16;break;}_context2.prev=3;_context2.next=6;return signedTxnPromise;case 6:_context2.next=14;break;case 8:_context2.prev=8;_context2.t0=_context2[\"catch\"](3);console.log('Caught failure',_context2.t0);if(!breakEarlyObject.breakEarly){_context2.next=14;break;}console.log('Died on ',breakEarlyObject.i);return _context2.abrupt(\"return\",{v:breakEarlyObject.i});case 14:_context2.next=17;break;case 16:pendingTxns.push(signedTxnPromise);case 17:case\"end\":return _context2.stop();}}},_loop2,null,[[3,8]]);});_i=0;case 29:if(!(_i<signedTxns.length)){_context3.next=37;break;}return _context3.delegateYield(_loop2(_i),\"t0\",31);case 31:_ret2=_context3.t0;if(!(typeof _ret2===\"object\")){_context3.next=34;break;}return _context3.abrupt(\"return\",_ret2.v);case 34:_i++;_context3.next=29;break;case 37:if(!(sequenceType!==SequenceType.Parallel)){_context3.next=40;break;}_context3.next=40;return Promise.all(pendingTxns);case 40:return _context3.abrupt(\"return\",signedTxns.length);case 41:case\"end\":return _context3.stop();}}},_callee2);}));return function sendTransactions(_x7,_x8,_x9,_x10){return _ref2.apply(this,arguments);};}();export var sendTransaction=/*#__PURE__*/function(){var _ref4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(connection,wallet,instructions,signers){var awaitConfirmation,commitment,includesFeePayer,block,transaction,_transaction,_transaction2,_transaction3,rawTransaction,options,txid,slot,confirmation,errors,_args4=arguments;return _regeneratorRuntime.wrap(function _callee3$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:awaitConfirmation=_args4.length>4&&_args4[4]!==undefined?_args4[4]:true;commitment=_args4.length>5&&_args4[5]!==undefined?_args4[5]:'singleGossip';includesFeePayer=_args4.length>6&&_args4[6]!==undefined?_args4[6]:false;block=_args4.length>7?_args4[7]:undefined;if(wallet.publicKey){_context4.next=6;break;}throw new WalletNotConnectedError();case 6:transaction=new Transaction();instructions.forEach(function(instruction){return transaction.add(instruction);});_context4.t0=block;if(_context4.t0){_context4.next=13;break;}_context4.next=12;return connection.getRecentBlockhash(commitment);case 12:_context4.t0=_context4.sent;case 13:transaction.recentBlockhash=_context4.t0.blockhash;if(includesFeePayer){(_transaction=transaction).setSigners.apply(_transaction,_toConsumableArray(signers.map(function(s){return s.publicKey;})));}else{(_transaction2=transaction).setSigners.apply(_transaction2,[// fee payed by the wallet owner\nwallet.publicKey].concat(_toConsumableArray(signers.map(function(s){return s.publicKey;}))));}if(signers.length>0){(_transaction3=transaction).partialSign.apply(_transaction3,_toConsumableArray(signers));}if(includesFeePayer){_context4.next=20;break;}_context4.next=19;return wallet.signTransaction(transaction);case 19:transaction=_context4.sent;case 20:rawTransaction=transaction.serialize();options={skipPreflight:true,commitment:commitment};_context4.next=24;return connection.sendRawTransaction(rawTransaction,options);case 24:txid=_context4.sent;slot=0;if(!awaitConfirmation){_context4.next=39;break;}_context4.next=29;return awaitTransactionSignatureConfirmation(txid,DEFAULT_TIMEOUT,connection,commitment);case 29:confirmation=_context4.sent;if(confirmation){_context4.next=32;break;}throw new Error('Timed out awaiting confirmation on transaction');case 32:slot=(confirmation===null||confirmation===void 0?void 0:confirmation.slot)||0;if(!(confirmation===null||confirmation===void 0?void 0:confirmation.err)){_context4.next=39;break;}_context4.next=36;return getErrorForTransaction(connection,txid);case 36:errors=_context4.sent;console.log(errors);throw new Error(\"Raw transaction \".concat(txid,\" failed\"));case 39:return _context4.abrupt(\"return\",{txid:txid,slot:slot});case 40:case\"end\":return _context4.stop();}}},_callee3);}));return function sendTransaction(_x11,_x12,_x13,_x14){return _ref4.apply(this,arguments);};}();export var sendTransactionWithRetry=/*#__PURE__*/function(){var _ref5=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(connection,wallet,instructions,signers){var commitment,includesFeePayer,block,beforeSend,transaction,_transaction4,_transaction5,_transaction6,_yield$sendSignedTran,txid,slot,_args5=arguments;return _regeneratorRuntime.wrap(function _callee4$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:commitment=_args5.length>4&&_args5[4]!==undefined?_args5[4]:'singleGossip';includesFeePayer=_args5.length>5&&_args5[5]!==undefined?_args5[5]:false;block=_args5.length>6?_args5[6]:undefined;beforeSend=_args5.length>7?_args5[7]:undefined;if(wallet.publicKey){_context5.next=6;break;}throw new WalletNotConnectedError();case 6:transaction=new Transaction();instructions.forEach(function(instruction){return transaction.add(instruction);});_context5.t0=block;if(_context5.t0){_context5.next=13;break;}_context5.next=12;return connection.getRecentBlockhash(commitment);case 12:_context5.t0=_context5.sent;case 13:transaction.recentBlockhash=_context5.t0.blockhash;if(includesFeePayer){(_transaction4=transaction).setSigners.apply(_transaction4,_toConsumableArray(signers.map(function(s){return s.publicKey;})));}else{(_transaction5=transaction).setSigners.apply(_transaction5,[// fee payed by the wallet owner\nwallet.publicKey].concat(_toConsumableArray(signers.map(function(s){return s.publicKey;}))));}if(signers.length>0){(_transaction6=transaction).partialSign.apply(_transaction6,_toConsumableArray(signers));}if(includesFeePayer){_context5.next=20;break;}_context5.next=19;return wallet.signTransaction(transaction);case 19:transaction=_context5.sent;case 20:if(beforeSend){beforeSend();}_context5.next=23;return sendSignedTransaction({connection:connection,signedTransaction:transaction});case 23:_yield$sendSignedTran=_context5.sent;txid=_yield$sendSignedTran.txid;slot=_yield$sendSignedTran.slot;return _context5.abrupt(\"return\",{txid:txid,slot:slot});case 27:case\"end\":return _context5.stop();}}},_callee4);}));return function sendTransactionWithRetry(_x15,_x16,_x17,_x18){return _ref5.apply(this,arguments);};}();export var getUnixTs=function getUnixTs(){return new Date().getTime()/1000;};var DEFAULT_TIMEOUT=15000;export function sendSignedTransaction(_x19){return _sendSignedTransaction.apply(this,arguments);}function _sendSignedTransaction(){_sendSignedTransaction=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee7(_ref6){var signedTransaction,connection,_ref6$timeout,timeout,rawTransaction,startTime,slot,txid,done,confirmation,simulateResult,i,line;return _regeneratorRuntime.wrap(function _callee7$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:signedTransaction=_ref6.signedTransaction,connection=_ref6.connection,_ref6$timeout=_ref6.timeout,timeout=_ref6$timeout===void 0?DEFAULT_TIMEOUT:_ref6$timeout;rawTransaction=signedTransaction.serialize();startTime=getUnixTs();slot=0;_context8.next=6;return connection.sendRawTransaction(rawTransaction,{skipPreflight:true});case 6:txid=_context8.sent;console.log('Started awaiting confirmation for',txid);done=false;_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee6(){return _regeneratorRuntime.wrap(function _callee6$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:if(!(!done&&getUnixTs()-startTime<timeout)){_context7.next=6;break;}connection.sendRawTransaction(rawTransaction,{skipPreflight:true});_context7.next=4;return sleep(500);case 4:_context7.next=0;break;case 6:case\"end\":return _context7.stop();}}},_callee6);}))();_context8.prev=10;_context8.next=13;return awaitTransactionSignatureConfirmation(txid,timeout,connection,'recent',true);case 13:confirmation=_context8.sent;if(confirmation){_context8.next=16;break;}throw new Error('Timed out awaiting confirmation on transaction');case 16:if(!confirmation.err){_context8.next=19;break;}console.error(confirmation.err);throw new Error('Transaction failed: Custom instruction error');case 19:slot=(confirmation===null||confirmation===void 0?void 0:confirmation.slot)||0;_context8.next=47;break;case 22:_context8.prev=22;_context8.t0=_context8[\"catch\"](10);console.error('Timeout Error caught',_context8.t0);if(!_context8.t0.timeout){_context8.next=27;break;}throw new Error('Timed out awaiting confirmation on transaction');case 27:simulateResult=null;_context8.prev=28;_context8.next=31;return simulateTransaction(connection,signedTransaction,'single');case 31:simulateResult=_context8.sent.value;_context8.next=36;break;case 34:_context8.prev=34;_context8.t1=_context8[\"catch\"](28);case 36:if(!(simulateResult&&simulateResult.err)){_context8.next=47;break;}if(!simulateResult.logs){_context8.next=46;break;}i=simulateResult.logs.length-1;case 39:if(!(i>=0)){_context8.next=46;break;}line=simulateResult.logs[i];if(!line.startsWith('Program log: ')){_context8.next=43;break;}throw new Error('Transaction failed: '+line.slice('Program log: '.length));case 43:--i;_context8.next=39;break;case 46:throw new Error(JSON.stringify(simulateResult.err));case 47:_context8.prev=47;done=true;return _context8.finish(47);case 50:console.log('Latency',txid,getUnixTs()-startTime);return _context8.abrupt(\"return\",{txid:txid,slot:slot});case 52:case\"end\":return _context8.stop();}}},_callee7,null,[[10,22,47,50],[28,34]]);}));return _sendSignedTransaction.apply(this,arguments);}function simulateTransaction(_x20,_x21,_x22){return _simulateTransaction.apply(this,arguments);}function _simulateTransaction(){_simulateTransaction=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee8(connection,transaction,commitment){var signData,wireTransaction,encodedTransaction,config,args,res;return _regeneratorRuntime.wrap(function _callee8$(_context9){while(1){switch(_context9.prev=_context9.next){case 0:_context9.next=2;return connection._recentBlockhash(// @ts-ignore\nconnection._disableBlockhashCaching);case 2:transaction.recentBlockhash=_context9.sent;signData=transaction.serializeMessage();// @ts-ignore\nwireTransaction=transaction._serialize(signData);encodedTransaction=wireTransaction.toString('base64');config={encoding:'base64',commitment:commitment};args=[encodedTransaction,config];// @ts-ignore\n_context9.next=10;return connection._rpcRequest('simulateTransaction',args);case 10:res=_context9.sent;if(!res.error){_context9.next=13;break;}throw new Error('failed to simulate transaction: '+res.error.message);case 13:return _context9.abrupt(\"return\",res.result);case 14:case\"end\":return _context9.stop();}}},_callee8);}));return _simulateTransaction.apply(this,arguments);}function awaitTransactionSignatureConfirmation(_x23,_x24,_x25){return _awaitTransactionSignatureConfirmation.apply(this,arguments);}function _awaitTransactionSignatureConfirmation(){_awaitTransactionSignatureConfirmation=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee11(txid,timeout,connection){var commitment,queryStatus,done,status,subId,_args12=arguments;return _regeneratorRuntime.wrap(function _callee11$(_context12){while(1){switch(_context12.prev=_context12.next){case 0:commitment=_args12.length>3&&_args12[3]!==undefined?_args12[3]:'recent';queryStatus=_args12.length>4&&_args12[4]!==undefined?_args12[4]:false;done=false;status={slot:0,confirmations:0,err:null};subId=0;_context12.next=7;return new Promise(/*#__PURE__*/function(){var _ref8=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee10(resolve,reject){return _regeneratorRuntime.wrap(function _callee10$(_context11){while(1){switch(_context11.prev=_context11.next){case 0:setTimeout(function(){if(done){return;}done=true;console.log('Rejecting for timeout...');reject({timeout:true});},timeout);try{subId=connection.onSignature(txid,function(result,context){done=true;status={err:result.err,slot:context.slot,confirmations:0};if(result.err){console.log('Rejected via websocket',result.err);reject(status);}else{console.log('Resolved via websocket',result);resolve(status);}},commitment);}catch(e){done=true;console.error('WS error in setup',txid,e);}case 2:if(!(!done&&queryStatus)){_context11.next=8;break;}// eslint-disable-next-line no-loop-func\n_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee9(){var signatureStatuses;return _regeneratorRuntime.wrap(function _callee9$(_context10){while(1){switch(_context10.prev=_context10.next){case 0:_context10.prev=0;_context10.next=3;return connection.getSignatureStatuses([txid]);case 3:signatureStatuses=_context10.sent;status=signatureStatuses&&signatureStatuses.value[0];if(!done){if(!status){console.log('REST null result for',txid,status);}else if(status.err){console.log('REST error for',txid,status);done=true;reject(status.err);}else if(!status.confirmations){console.log('REST no confirmations for',txid,status);}else{console.log('REST confirmation for',txid,status);done=true;resolve(status);}}_context10.next=11;break;case 8:_context10.prev=8;_context10.t0=_context10[\"catch\"](0);if(!done){console.log('REST connection error: txid',txid,_context10.t0);}case 11:case\"end\":return _context10.stop();}}},_callee9,null,[[0,8]]);}))();_context11.next=6;return sleep(2000);case 6:_context11.next=2;break;case 8:case\"end\":return _context11.stop();}}},_callee10);}));return function(_x26,_x27){return _ref8.apply(this,arguments);};}());case 7:status=_context12.sent;//@ts-ignore\nif(connection._signatureSubscriptions[subId])connection.removeSignatureListener(subId);done=true;console.log('Returning status',status);return _context12.abrupt(\"return\",status);case 12:case\"end\":return _context12.stop();}}},_callee11);}));return _awaitTransactionSignatureConfirmation.apply(this,arguments);}export function sleep(ms){return new Promise(function(resolve){return setTimeout(resolve,ms);});}","map":{"version":3,"sources":["/Users/timgillam/Documents/GitHub/metaplex_new/new-metaplex/js/packages/fair-launch/src/connection.tsx"],"names":["Transaction","WalletNotConnectedError","getErrorForTransaction","connection","txid","confirmTransaction","getParsedConfirmedTransaction","tx","errors","meta","logMessages","forEach","log","regex","m","exec","index","lastIndex","length","push","SequenceType","sendTransactionsWithManualRetry","wallet","instructions","signers","stopPoint","tries","lastInstructionsLength","toRemoveSigners","filter","instr","i","filteredSigners","_","slice","sendTransactionWithRetry","sendTransactions","StopOnFailure","console","error","instructionSet","signersSet","sequenceType","Parallel","commitment","successCallback","ind","failCallback","block","publicKey","unsignedTxns","getRecentBlockhash","transaction","instruction","add","recentBlockhash","blockhash","setSigners","map","s","partialSign","signAllTransactions","signedTxns","pendingTxns","breakEarlyObject","breakEarly","signedTxnPromise","sendSignedTransaction","signedTransaction","then","slot","catch","reason","Promise","all","sendTransaction","awaitConfirmation","includesFeePayer","signTransaction","rawTransaction","serialize","options","skipPreflight","sendRawTransaction","awaitTransactionSignatureConfirmation","DEFAULT_TIMEOUT","confirmation","Error","err","beforeSend","getUnixTs","Date","getTime","timeout","startTime","done","sleep","simulateResult","simulateTransaction","value","logs","line","startsWith","JSON","stringify","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","config","encoding","args","_rpcRequest","res","message","result","queryStatus","status","confirmations","subId","resolve","reject","setTimeout","onSignature","context","e","getSignatureStatuses","signatureStatuses","_signatureSubscriptions","removeSignatureListener","ms"],"mappings":"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","sourcesContent":["import {\n  Keypair,\n  Commitment,\n  Connection,\n  RpcResponseAndContext,\n  SignatureStatus,\n  SimulatedTransactionResponse,\n  Transaction,\n  TransactionInstruction,\n  TransactionSignature,\n  Blockhash,\n  FeeCalculator,\n} from '@solana/web3.js';\n\nimport {\n  WalletNotConnectedError,\n} from '@solana/wallet-adapter-base';\n\ninterface BlockhashAndFeeCalculator {\n  blockhash: Blockhash;\n  feeCalculator: FeeCalculator;\n}\n\nexport const getErrorForTransaction = async (\n  connection: Connection,\n  txid: string,\n) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, 'max');\n\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n\n  const errors: string[] = [];\n  if (tx?.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach(log => {\n      const regex = /Error: (.*)/gm;\n      let m;\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\n\nexport enum SequenceType {\n  Sequential,\n  Parallel,\n  StopOnFailure,\n}\n\nexport async function sendTransactionsWithManualRetry(\n  connection: Connection,\n  wallet: any,\n  instructions: TransactionInstruction[][],\n  signers: Keypair[][],\n) {\n  let stopPoint = 0;\n  let tries = 0;\n  let lastInstructionsLength = null;\n  let toRemoveSigners: Record<number, boolean> = {};\n  instructions = instructions.filter((instr, i) => {\n    if (instr.length > 0) {\n      return true;\n    } else {\n      toRemoveSigners[i] = true;\n      return false;\n    }\n  });\n  let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);\n\n  while (stopPoint < instructions.length && tries < 3) {\n    instructions = instructions.slice(stopPoint, instructions.length);\n    filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);\n\n    if (instructions.length === lastInstructionsLength) tries = tries + 1;\n    else tries = 0;\n\n    try {\n      if (instructions.length === 1) {\n        await sendTransactionWithRetry(\n          connection,\n          wallet,\n          instructions[0],\n          filteredSigners[0],\n          'single',\n        );\n        stopPoint = 1;\n      } else {\n        stopPoint = await sendTransactions(\n          connection,\n          wallet,\n          instructions,\n          filteredSigners,\n          SequenceType.StopOnFailure,\n          'single',\n        );\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    console.log(\n      'Died on ',\n      stopPoint,\n      'retrying from instruction',\n      instructions[stopPoint],\n      'instructions length is',\n      instructions.length,\n    );\n    lastInstructionsLength = instructions.length;\n  }\n}\n\nexport const sendTransactions = async (\n  connection: Connection,\n  wallet: any,\n  instructionSet: TransactionInstruction[][],\n  signersSet: Keypair[][],\n  sequenceType: SequenceType = SequenceType.Parallel,\n  commitment: Commitment = 'singleGossip',\n  successCallback: (txid: string, ind: number) => void = (txid, ind) => {},\n  failCallback: (reason: string, ind: number) => boolean = (txid, ind) => false,\n  block?: BlockhashAndFeeCalculator,\n): Promise<number> => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  const unsignedTxns: Transaction[] = [];\n\n  if (!block) {\n    block = await connection.getRecentBlockhash(commitment);\n  }\n\n  for (let i = 0; i < instructionSet.length; i++) {\n    const instructions = instructionSet[i];\n    const signers = signersSet[i];\n\n    if (instructions.length === 0) {\n      continue;\n    }\n\n    let transaction = new Transaction();\n    instructions.forEach(instruction => transaction.add(instruction));\n    transaction.recentBlockhash = block.blockhash;\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n\n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n\n    unsignedTxns.push(transaction);\n  }\n\n  const signedTxns = await wallet.signAllTransactions(unsignedTxns);\n\n  const pendingTxns: Promise<{ txid: string; slot: number }>[] = [];\n\n  let breakEarlyObject = { breakEarly: false, i: 0 };\n  console.log(\n    'Signed txns length',\n    signedTxns.length,\n    'vs handed in length',\n    instructionSet.length,\n  );\n  for (let i = 0; i < signedTxns.length; i++) {\n    const signedTxnPromise = sendSignedTransaction({\n      connection,\n      signedTransaction: signedTxns[i],\n    });\n\n    signedTxnPromise\n      .then(({ txid, slot }) => {\n        successCallback(txid, i);\n      })\n      .catch(reason => {\n        // @ts-ignore\n        failCallback(signedTxns[i], i);\n        if (sequenceType === SequenceType.StopOnFailure) {\n          breakEarlyObject.breakEarly = true;\n          breakEarlyObject.i = i;\n        }\n      });\n\n    if (sequenceType !== SequenceType.Parallel) {\n      try {\n        await signedTxnPromise;\n      } catch (e) {\n        console.log('Caught failure', e);\n        if (breakEarlyObject.breakEarly) {\n          console.log('Died on ', breakEarlyObject.i);\n          return breakEarlyObject.i; // Return the txn we failed on by index\n        }\n      }\n    } else {\n      pendingTxns.push(signedTxnPromise);\n    }\n  }\n\n  if (sequenceType !== SequenceType.Parallel) {\n    await Promise.all(pendingTxns);\n  }\n\n  return signedTxns.length;\n};\n\nexport const sendTransaction = async (\n  connection: Connection,\n  wallet: any,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  awaitConfirmation = true,\n  commitment: Commitment = 'singleGossip',\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  const rawTransaction = transaction.serialize();\n  let options = {\n    skipPreflight: true,\n    commitment,\n  };\n\n  const txid = await connection.sendRawTransaction(rawTransaction, options);\n  let slot = 0;\n\n  if (awaitConfirmation) {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      DEFAULT_TIMEOUT,\n      connection,\n      commitment,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n    slot = confirmation?.slot || 0;\n\n    if (confirmation?.err) {\n      const errors = await getErrorForTransaction(connection, txid);\n\n      console.log(errors);\n      throw new Error(`Raw transaction ${txid} failed`);\n    }\n  }\n\n  return { txid, slot };\n};\n\nexport const sendTransactionWithRetry = async (\n  connection: Connection,\n  wallet: any,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  commitment: Commitment = 'singleGossip',\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n  beforeSend?: () => void,\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n\n  const { txid, slot } = await sendSignedTransaction({\n    connection,\n    signedTransaction: transaction,\n  });\n\n  return { txid, slot };\n};\n\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\n\nconst DEFAULT_TIMEOUT = 15000;\n\nexport async function sendSignedTransaction({\n  signedTransaction,\n  connection,\n  timeout = DEFAULT_TIMEOUT,\n}: {\n  signedTransaction: Transaction;\n  connection: Connection;\n  sendingMessage?: string;\n  sentMessage?: string;\n  successMessage?: string;\n  timeout?: number;\n}): Promise<{ txid: string; slot: number }> {\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid: TransactionSignature = await connection.sendRawTransaction(\n    rawTransaction,\n    {\n      skipPreflight: true,\n    },\n  );\n\n  console.log('Started awaiting confirmation for', txid);\n\n  let done = false;\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true,\n      });\n      await sleep(500);\n    }\n  })();\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      timeout,\n      connection,\n      'recent',\n      true,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n\n    if (confirmation.err) {\n      console.error(confirmation.err);\n      throw new Error('Transaction failed: Custom instruction error');\n    }\n\n    slot = confirmation?.slot || 0;\n  } catch (err: any) {\n    console.error('Timeout Error caught', err);\n    if (err.timeout) {\n      throw new Error('Timed out awaiting confirmation on transaction');\n    }\n    let simulateResult: SimulatedTransactionResponse | null = null;\n    try {\n      simulateResult = (\n        await simulateTransaction(connection, signedTransaction, 'single')\n      ).value;\n    } catch (e) {}\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n          if (line.startsWith('Program log: ')) {\n            throw new Error(\n              'Transaction failed: ' + line.slice('Program log: '.length),\n            );\n          }\n        }\n      }\n      throw new Error(JSON.stringify(simulateResult.err));\n    }\n    // throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n\n  console.log('Latency', txid, getUnixTs() - startTime);\n  return { txid, slot };\n}\n\nasync function simulateTransaction(\n  connection: Connection,\n  transaction: Transaction,\n  commitment: Commitment,\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n    // @ts-ignore\n    connection._disableBlockhashCaching,\n  );\n\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString('base64');\n  const config: any = { encoding: 'base64', commitment };\n  const args = [encodedTransaction, config];\n\n  // @ts-ignore\n  const res = await connection._rpcRequest('simulateTransaction', args);\n  if (res.error) {\n    throw new Error('failed to simulate transaction: ' + res.error.message);\n  }\n  return res.result;\n}\n\nasync function awaitTransactionSignatureConfirmation(\n  txid: TransactionSignature,\n  timeout: number,\n  connection: Connection,\n  commitment: Commitment = 'recent',\n  queryStatus = false,\n): Promise<SignatureStatus | null | void> {\n  let done = false;\n  let status: SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({ timeout: true });\n    }, timeout);\n    try {\n      subId = connection.onSignature(\n        txid,\n        (result, context) => {\n          done = true;\n          status = {\n            err: result.err,\n            slot: context.slot,\n            confirmations: 0,\n          };\n          if (result.err) {\n            console.log('Rejected via websocket', result.err);\n            reject(status);\n          } else {\n            console.log('Resolved via websocket', result);\n            resolve(status);\n          }\n        },\n        commitment,\n      );\n    } catch (e) {\n      done = true;\n      console.error('WS error in setup', txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId])\n    connection.removeSignatureListener(subId);\n  done = true;\n  console.log('Returning status', status);\n  return status;\n}\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n"]},"metadata":{},"sourceType":"module"}